# [SPX-002] Implement Event Loop Run/Stop Logic

**Status:** PENDING
**Phase:** 1 - Event Loop Foundation
**Dependencies:** [SPX-001] Implement PlexEventLoop Core Structure

---

## Description

Add the main event loop execution with io_uring submission/completion processing. This implements the core event loop that will process async I/O operations and dispatch to PlexItem handlers.

## Definition of Done

- [ ] File: `apps/spikes/samplex/src/plex_uring.c` (updated)
- [ ] Functions implemented:
  - [ ] `plex_event_loop_run(PlexEventLoop* loop)`
  - [ ] `plex_event_loop_stop(PlexEventLoop* loop)`
- [ ] Event loop processes io_uring CQEs and dispatches to handlers
- [ ] Graceful shutdown on stop signal
- [ ] Basic error handling for io_uring operations
- [ ] Code compiles without warnings
- [ ] Test demonstrates run/stop cycle

---

## 1. Discovery (Context Audit)

### Search for Similar Patterns
```bash
# Check for existing event loop patterns in codebase
grep -r "while.*running" apps/

# Check existing PlexItem handler patterns
grep -r "PlexItem" apps/spikes/samplex/
```

### Dependencies Verification
- **PlexEventLoop**: From [SPX-001]
- **io_uring API**:
  - `io_uring_submit()` - Submit queued operations
  - `io_uring_wait_cqe()` - Wait for completions
  - `io_uring_cqe_seen()` - Mark completion as processed
- **PlexItem handlers**: Existing pattern from plex.h

### File Location
- Update: `apps/spikes/samplex/src/plex_uring.h` (add function prototypes)
- Update: `apps/spikes/samplex/src/plex_uring.c` (add implementations)
- Update: `apps/spikes/samplex/src/main.c` (add run/stop test)

---

## 2. Technical Design

### Function Signatures
```c
// plex_uring.h

// Run the event loop (blocking until stopped)
// Returns 0 on clean shutdown, -1 on error
int plex_event_loop_run(PlexEventLoop* loop);

// Signal the event loop to stop
// Thread-safe, can be called from signal handlers
void plex_event_loop_stop(PlexEventLoop* loop);
```

### Event Loop Logic
```c
// Pseudocode for plex_event_loop_run():
// 1. Validate loop != NULL
// 2. Set loop->running = true
// 3. While (loop->running):
//    a. Submit pending SQEs: io_uring_submit()
//    b. Wait for completion: io_uring_wait_cqe()
//    c. Process CQE:
//       - Extract user_data (should point to PlexItem or context)
//       - Call appropriate handler based on CQE result
//       - Mark CQE as seen: io_uring_cqe_seen()
//    d. Handle errors (negative CQE result codes)
// 4. Return 0 (clean shutdown)
```

### Safety Considerations
- NULL pointer checks for loop parameter
- Handle io_uring_wait_cqe() errors (EINTR, EAGAIN)
- Protect against infinite loops with running flag
- Ensure all pending operations complete before shutdown
- Handle case where no operations are queued (would block forever)

### Handler Dispatch Strategy
For this foundational ticket, we don't have actual operations yet:
- Create a simple test operation (NOP or timeout) to verify loop works
- Store PlexItem pointer in io_uring user_data field
- Call PlexItem success_handler on positive CQE result
- Call PlexItem error_handler on negative CQE result

---

## 3. Step-by-Step Execution Plan

### Step 1: Update plex_uring.h
- [ ] Add `plex_event_loop_run()` prototype
- [ ] Add `plex_event_loop_stop()` prototype
- [ ] Add comments documenting behavior

### Step 2: Implement plex_event_loop_stop()
- [ ] Validate loop != NULL
- [ ] Set `loop->running = false`
- [ ] (Optional) Submit a wake-up event if needed to break wait

### Step 3: Implement plex_event_loop_run() - skeleton
- [ ] Validate loop != NULL
- [ ] Set `loop->running = true`
- [ ] Create main while loop: `while (loop->running)`
- [ ] Add placeholder for SQE submission
- [ ] Add placeholder for CQE processing
- [ ] Return 0 on exit

### Step 4: Implement CQE wait logic
- [ ] Call `io_uring_submit()` to submit pending operations
- [ ] Call `io_uring_wait_cqe()` to wait for completion
- [ ] Handle EINTR (interrupted by signal - continue loop)
- [ ] Handle other errors (log and return -1)

### Step 5: Implement CQE processing
- [ ] Extract `user_data` from CQE
- [ ] Cast user_data to appropriate type (PlexItem* or custom context)
- [ ] Check CQE result code (res field)
- [ ] If res >= 0: success path (call handler if exists)
- [ ] If res < 0: error path (call error handler if exists)
- [ ] Call `io_uring_cqe_seen()` to mark CQE processed

### Step 6: Add test operation support
- [ ] Submit a simple timeout operation (IORING_OP_TIMEOUT)
- [ ] Set timeout to 1 second for testing
- [ ] Create a dummy PlexItem with success_handler that calls stop
- [ ] Store PlexItem pointer in user_data

### Step 7: Update main.c with run/stop test
- [ ] Create PlexRegistry
- [ ] Create PlexEventLoop
- [ ] Submit test timeout operation
- [ ] Call plex_event_loop_run() (should run for ~1 second)
- [ ] Verify loop exits cleanly
- [ ] Print success message
- [ ] Clean up resources

### Step 8: Build and test
- [ ] Compile with `make samplex`
- [ ] Run and verify 1-second delay then clean exit
- [ ] Check for memory leaks with valgrind (optional)

---

## 4. Implementation

Execute the plan from Step 3. Check off items as completed.

---

## 5. Verification (The "Must-Haves")

### Build Test
```bash
cd build
make samplex
```
- [ ] Compiles without errors
- [ ] Compiles without warnings (-Wall -Wextra)

### Usage Test
```bash
./build/apps/spikes/samplex/samplex
```
- [ ] Event loop runs
- [ ] Test operation (timeout) fires correctly
- [ ] Loop exits gracefully after timeout
- [ ] No crashes or hangs
- [ ] Clean shutdown message printed

### Behavior Verification
- [ ] Loop runs until stop is called
- [ ] Stop signal is respected
- [ ] CQE processing works (handler is called)
- [ ] No busy-waiting (loop blocks on io_uring_wait_cqe)

### Sanity Check
- [ ] Matches Technical Design from Step 2
- [ ] Follows io_uring best practices
- [ ] Proper error handling for io_uring operations
- [ ] Clean resource management

### Cleanup
- [ ] Remove any debug printf statements (except intentional test output)
- [ ] Remove commented-out code
- [ ] Ensure consistent formatting

---

## 6. Completion

- [ ] Mark this ticket as **DONE** in tracking document
- [ ] Update `planning/active/samplex_async_engine.md` progress
- [ ] Phase 1 complete - ready to proceed to Phase 2 [SPX-003]

---

## Notes

This ticket establishes the core event loop mechanism. Subsequent tickets will add:
- Timer support (Phase 2)
- Network operations (Phase 3)
- PostgreSQL operations (Phase 4)

The simple timeout operation in this ticket serves as a proof-of-concept for the handler dispatch mechanism that will be used throughout the system.
